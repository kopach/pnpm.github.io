<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/it/blog</id>
    <title>pnpm Blog</title>
    <updated>2020-10-17T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/it/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/it/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[Opzioni di configurazione di Node-Modules con pnpm]]></title>
        <id>Opzioni di configurazione di Node-Modules con pnpm</id>
        <link href="https://pnpm.io/it/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Esistono molti modi per creare una cartella nodemodules. Il tuo obiettivo deve essere quello di creare la più rigorosa, ma se ciò non è possibile, ci sono anche opzioni per creare una cartella nodemodules sciolta.]]></summary>
        <content type="html"><![CDATA[<p>Esistono molti modi per creare una cartella node_modules. Il tuo obiettivo deve essere quello di creare la più rigorosa, ma se ciò non è possibile, ci sono anche opzioni per creare una cartella node_modules sciolta.</p><h2>Configurazione predefinita</h2><p>Per impostazione predefinita, pnpm v5 crea una cartella node_modules semi-rigorosa. Semi-rigorosa significa che la tua applicazione sarà in grado di utilizzare solo i pacchetti che sono stati aggiunti come dipendenze in <code>package.json</code> (con alcune eccezioni). Tuttavia, le tue dipendenze saranno in grado di accedere a qualsiasi pacchetto.</p><p>La configurazione predefinita è simile a questa:</p><pre><code class="language-ini">; Tutti i pacchetti vengono installati in node_modules/.pnpm/node_modules
hoist-pattern[]=*

; Tutti i tipi vengono installati alla radice per rendere felice TypeScript
public-hoist-pattern[]=*types*

; Tutti i pacchetti relativi a ESLint vengono installati alla radice anch&#x27;essi
public-hoist-pattern[]=*eslint*
</code></pre><h2>Plug&#x27;n&#x27;Play. La configurazione più rigorosa</h2><p>pnpm supporta il <a href="https://yarnpkg.com/features/pnp">Plug&#x27;n&#x27;Play di Yarn</a> dalla versione v5.9. Con PnP, sia la tua applicazione che le dipendenze della tua applicazione avranno accesso solo alle loro dipendenze dichiarate. Questo è ancora più rigoroso dell&#x27;impostazione <code>hoist=false</code> perché all&#x27;interno di un monorepo, la tua applicazione non sarà in grado di accedere nemmeno alle dipendenze del progetto root.</p><p>Per utilizzare Plug&#x27;n&#x27;Play, imposta queste impostazioni:</p><pre><code class="language-ini">node-linker=pnp
symlink=false
</code></pre><h2>Una cartella di moduli rigorosa e tradizionale</h2><p>Se non sei ancora pronto per utilizzare PnP, puoi comunque essere rigoroso e consentire solo ai pacchetti di accedere alle proprie dipendenze impostando la configurazione dell&#x27;hoist su false:</p><pre><code class="language-ini">hoist=false
</code></pre><p>Tuttavia, se alcune delle tue dipendenze stanno tentando di accedere a pacchetti che non hanno nelle dipendenze, hai due opzioni:</p><ol><li><p>Crea un <code>pnpmfile.js</code> e usa un <a href="/pnpmfile">hook</a> per aggiungere la dipendenza mancante al manifest del pacchetto.</p></li><li><p>Aggiungi un modello all&#x27;impostazione <code>hoist-pattern</code>. Ad esempio, se il modulo non trovato è <code>babel-core</code>, aggiungi la seguente impostazione a <code>.npmrc</code>:</p><pre><code class="language-ini">hoist-pattern[]=babel-core
</code></pre></li></ol><h2>Il caso peggiore - installazione alla radice</h2><p>Alcuni strumenti potrebbero non funzionare anche con la configurazione predefinita di pnpm, che installa tutto alla radice dell&#x27;archivio virtuale e alcuni pacchetti alla radice. In questo caso, puoi installare tutto o un sottoinsieme di dipendenze alla radice della cartella dei moduli.</p><p>Installa tutto alla radice di node_modules:</p><pre><code class="language-ini">shamefully-hoist=true
</code></pre><p>Installa solo i pacchetti che corrispondono a un modello:</p><pre><code class="language-ini">public-hoist-pattern[]=babel-*
</code></pre>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[La node_modules flat non è l'unico modo]]></title>
        <id>La node_modules flat non è l'unico modo</id>
        <link href="https://pnpm.io/it/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I nuovi utenti di pnpm mi chiedono spesso della strana struttura di node_modules che crea pnpm. Perché non è piatta? Dove sono tutte le dipendenze secondarie?]]></summary>
        <content type="html"><![CDATA[<p>I nuovi utenti di pnpm mi chiedono spesso della strana struttura di <code>node_modules</code> che crea pnpm. Perché non è piatta? Dove sono tutte le dipendenze secondarie?</p><blockquote><p>Presumo che i lettori dell&#x27;articolo abbiano già familiarità con la cartella <code>node_modules</code> piatta creata da npm e Yarn. Se non capisci perché npm 3 ha dovuto iniziare a utilizzare <code>node_modules</code> flat nella v3, puoi trovare un po&#x27; di preistoria in <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Perché dovremmo usare pnpm?</a>.</p></blockquote><p>Perché allora <code>node_modules</code> di pnpm è insolito? Creiamo due cartelle ed eseguiamo <code>npm add express</code> in una di esse e <code>pnpm add express</code> nell&#x27;altra. Ecco la parte superiore di ciò che si ottiene in <code>node_modules</code> della prima cartella:</p><pre><code class="language-text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express
</code></pre><p>Puoi vedere l&#x27;intera cartella <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">qui</a>.</p><p>E questo è ciò che ottieni in <code>node_modules</code> creato da pnpm:</p><pre><code class="language-text">.pnpm
.modules.yaml
express
</code></pre><p>Puoi controllarlo <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">qui</a>.</p><p>Allora, dove sono tutte le dipendenze? C&#x27;è solo una cartella in <code>node_modules</code> chiamata <code>.pnpm</code> e un collegamento simbolico chiamato <code>express</code>. Bene, abbiamo installato solo <code>express</code>, quindi questo è l&#x27;unico pacchetto a cui la tua applicazione deve avere accesso</p><blockquote><p>Leggi di più sul perché la severità di pnpm è una buona cosa <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">qui</a></p></blockquote><p>Vediamo cosa c&#x27;è dentro <code>express</code>:</p><pre><code class="language-text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
    .modules.yaml
</code></pre><p><code>express</code> non ha <code>node_modules</code>? Dove sono tutte le dipendenze di <code>express</code>?</p><p>Il trucco è che <code>express</code> è solo un collegamento simbolico. Quando Node.js risolve le dipendenze, utilizza le loro posizioni reali, quindi non conserva i collegamenti simbolici. Ma dov&#x27;è la vera posizione di <code>express</code>, si potrebbe chiedere?</p><p>Qui: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>OK, ora conosciamo lo scopo della cartella <code>.pnpm/</code>. <code>.pnpm/</code> memorizza tutti i pacchetti in una struttura di cartelle piatte, quindi ogni pacchetto può essere trovato in una cartella denominata con questo modello:</p><pre><code class="language-text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;
</code></pre><p>La chiamiamo cartella dell&#x27;archivio virtuale.</p><p>Questa struttura piatta evita i problemi di percorso lunghi che sono stati causati dai <code>node_modules</code> annidati creati da npm v2 ma mantiene i pacchetti isolati a differenza dei <code>node_modules</code> piatti creati da npm v3,4,5,6 o yarn v1.</p><p>Ora diamo un&#x27;occhiata alla vera posizione di <code>express</code>:</p><pre><code class="language-text">  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>È una truffa? Manca ancora la cartella <code>node_modules</code>! Il secondo trucco della struttura <code>node_modules</code> di pnpm è che le dipendenze dei pacchetti sono sullo stesso livello di cartella su cui si trova la posizione reale del pacchetto dipendente. Quindi le dipendenze di <code>express</code> non sono in <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> ma in <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm/express@4.17.1/node_modules/</a>:</p><pre><code class="language-text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
</code></pre><p>Tutte le dipendenze di <code>express</code> sono collegamenti simbolici a cartelle appropriate in <code>node_modules/.pnpm/</code>. Posizionare le dipendenze di <code>express</code> un livello in alto permette di evitare i collegamenti simbolici circolari.</p><p>Quindi, come puoi vedere, anche se la struttura <code>node_modules</code> di pnpm sembra inizialmente inusuale:</p><ol><li>è completamente compatibile con Node.js</li><li>i pacchetti sono ben raggruppati con le loro dipendenze</li></ol><p>La struttura è un po&#x27; <a href="/how-peers-are-resolved">più complessa</a> per i pacchetti con dipendenze peer ma l&#x27;idea è la stessa: usare collegamenti simbolici per creare un annidamento con una struttura di cartelle piatta.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>